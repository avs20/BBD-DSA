class Solution:
    # O(n) | O(n)
    def isPalindrome(self, s: str) -> bool:
        arr = []
        for ch in s:
            if ch.isalnum():
                arr.append(ch.lower())
        
        return arr == arr[::-1]
    
======================
JAVA
======================
public class Solution {
    public boolean isPalindrome(String s) {
        StringBuilder cleanString = new StringBuilder();
        for (char ch : s.toCharArray()) {
            if (Character.isLetterOrDigit(ch)) {
                cleanString.append(Character.toLowerCase(ch));
            }
        }
        
        String forward = cleanString.toString();
        String backward = cleanString.reverse().toString();
        
        return forward.equals(backward);
    }
}


=======================
# using left and right pointers

class Solution:
    # O(n) | O(1)
    def isPalindrome(self, s: str) -> bool:
        l = 0
        r = len(s) -1 

        while l < r :

            while l < r  and not s[l].isalnum():
                l += 1
            while r > l and not [r].isalnum():
                r -= 1 
            
            if s[l].lower() != s[r].lower():
                return False
            l += 1
            r -= 1

        return True

=======================
JAVA
=======================
class Solution {
    public boolean isPalindrome(String s) {
        s = s.toLowerCase().replaceAll("[^a-z0-9]", "");
        int i = 0;
        int j = s.length() - 1;
        while(i <= j) {
            if (s.charAt(i) != s.charAt(j)) {
                return false;
            }
            i++;
            j--;
        }
        return true;
    }
}

======================
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        sCount = {}
        tCount = {}

        for ch in s:
            sCount[ch] = sCount.get(ch, 0) + 1
        
        for ch in t:
            tCount[ch] = tCount.get(ch, 0) + 1
        
        return sCount == tCount
    

======================
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        sCount = Counter(s)
        tCount = Counter(s)
    
        return sCount == tCount

======================
JAVA
import java.util.HashMap;

public class Solution {
    public boolean isAnagram(String s, String t) {
        if (s.length() != t.length()) {
            return false;
        }

        HashMap<Character, Integer> sCount = new HashMap<>();
        HashMap<Character, Integer> tCount = new HashMap<>();

        for (int i = 0; i < s.length(); i++) {
            sCount.put(s.charAt(i), sCount.getOrDefault(s.charAt(i), 0) + 1);
            tCount.put(t.charAt(i), tCount.getOrDefault(t.charAt(i), 0) + 1);
        }

        return sCount.equals(tCount);
    }
}
======================
class Solution

==========================
Longest Palindrome
==========================
class Solution:
    def longestPalindrome(self, s: str) -> int:
        hmap = {}
        for ch in s:
            hmap[ch] = hmap.get(ch,0) + 1
        
        ans = 0
        odd = False
        for key, value in hmap.items():
            ans += value // 2 * 2
            if value % 2 :
                odd = True
        
        return ans + 1 if odd else ans

=============================
JAVA
=============================
import java.util.HashMap;

public class Solution {
    public int longestPalindrome(String s) {
        HashMap<Character, Integer> hmap = new HashMap<>();
        for (char ch : s.toCharArray()) {
            hmap.put(ch, hmap.getOrDefault(ch, 0) + 1);
        }

        int ans = 0;
        boolean odd = false;
        for (int value : hmap.values()) {
            ans += value / 2 * 2;
            if (value % 2 == 1) {
                odd = true;
            }
        }

        return odd ? ans + 1 : ans;
    }
}
        

==========================
Longest substring without repeating characters
==========================
class Solution(object):
    def lengthOfLongestSubstring(self, s):
        """
        :type s: str
        :rtype: int
        """
        
        l = 0
        r = 0 
        hmap = {}

        res = 0
        while r < len(s):
            ch = s[r]
            hmap[ch] = hmap.get(ch,0) + 1

            while hmap[s[r]] > 1:
                hmap[s[l]] = hmap[s[l]] - 1
                l += 1 

            res = max(res, r-l+1)

            r += 1
        
        return res
            


        
        

