class Solution:
    def myAtoi(self, s: str) -> int:

        s = s.strip()
        if len(s) == 0 : return 0

        sign = 1 
        res = 0

        if s[0] == "-":
            sign = -1 
        elif s[0] == "+":
            sign = 1 
        elif not s[0].isnumeric():
            return 0
        else:
            res = res * 10 + int(s[0])
        
        for i in range(1, len(s)):
            if s[i].isnumeric():
                res = res * 10 + int(s[i])
            else:
                break
        
        if sign == 1:
            res = min(res, 2**31 - 1)
        else:
            res = min(res, 2**31)
        
        return res * sign
    
==========================
JAVA
==========================
class Solution {
    public int myAtoi(String s) {
        s = s.trim();
        if (s.length() == 0) return 0;
        
        int sign = 1;
        int res = 0;
        
        if (s.charAt(0) == '-') {
            sign = -1;
        } else if (s.charAt(0) == '+') {
            sign = 1;
        } else if (!Character.isDigit(s.charAt(0))) {
            return 0;
        } else {
            res = res * 10 + Character.getNumericValue(s.charAt(0));
        }
        
        for (int i = 1; i < s.length(); i++) {
            if (Character.isDigit(s.charAt(i))) {
                res = res * 10 + Character.getNumericValue(s.charAt(i));
            } else {
                break;
            }
        }
        
        if (sign == 1) {
            res = Math.min(res, Integer.MAX_VALUE);
        } else {
            res = Math.min(res, Integer.MAX_VALUE);
        }
        
        return res * sign;
    }
}



======================================
Longest Palindromic Substring
=====================================

class Solution:
    def longestPalindrome(self, s: str) -> str:

        l , r = 0, 0 
        ans = ""
        maxlen = 0
        for i in range(len(s)):

            l = i 
            r = i 

            while l >= 0 and r < len(s) and s[l] == s[r]:
                l -= 1 
                r += 1 
            
            if r - l - 1 > maxlen:
                maxlen = r - l - 1
                ans = s[l+1:r]
            
            l = i
            r = i + 1

            while l >= 0 and r < len(s) and s[l] == s[r]:
                l -= 1 
                r += 1
            
            if r - l - 1  >maxlen:
                maxlen = r - l -1 
                ans = s[l+1:r]
            
        
        return ans 



    
==========================
JAVA
==========================
class Solution {
    public String longestPalindrome(String s) {
        if (s.length() == 0) {
            return "";
        }

        char[] sChars = s.toCharArray();

        int start = 0;
        int end = 0;

        for (int i = 0; i < sChars.length; i++) {
            int len = Math.max(expand(sChars, i, i), expand(sChars, i, i + 1));

            if (len > end - start + 1) {
                start = i - (len - 1) / 2;
                end = i + len / 2;
            }
        }

        return s.substring(start, end + 1);
    }

    public int expand(char[] sChars, int i, int j) {
        while (i >= 0 && j < sChars.length && sChars[i] == sChars[j]) {
            i--;
            j++;
        }
        return j - i - 1;
    }
}






